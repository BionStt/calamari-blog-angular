<article class="post single">
    <section class="post__content">
        <div class="post__detail">
            <header class="post__header">
                <h1 class="alpha post__title" itemprop="name headline">
                    Preloading ngrx/store with Route Guards
                    <div class="post-card__container">
                        <div class="post-card__meta">
                            <div class="post-card__tag">
                                <img src="/img/tags/angular.svg" alt="">
                            </div>
                            Aug 24, 2017
                        </div>
                        <div class="post-card__meta">
                            <div class="post-card__tag">
                                <img src="/img/tags/time.svg" alt="">
                            </div>
                            4 mins read
                        </div>
                        <div class="post-card__meta">
                            <div class="post-card__tag">
                                <img src="/img/icons/github-dark.svg" alt="">
                            </div>
                            <a class="post-card-edit" href="//github.com/toddmotto/toddmotto.github.io/blob/master/_posts/2017-08-24-preloading-ngrx-store-route-guards.md">
                                Edit post
                            </a>
                        </div>

                    </div>
                </h1>
                <div class="post__meta__divider"></div>
            </header>
            <p>Using ngrx/store (and some love for ngrx/effects) is definitely a great step for my productivity when managing state in Angular, and I want to share a small setup that'll allow you to preload data as normal with a Route Guard. The interesting thing is that the route guard will also make an API request if we currently have no data in the Store - and populate the store with the data before we finish transitioning to the route.</p>
            <p>This is great, because I can hit a particular route, it loads the data and populates my store, at which point I can navigate away from the route and come back. When I come back - as long as I haven't refreshed the app the data will still be in the Store, and skip the API request. This is neat!</p>
            <div class="toc">
                <p class="no_toc"><span class="gamma">Table of contents</span></p>
                <ul id="markdown-toc">
                    <li><a href="#routes-setup" id="markdown-toc-routes-setup">Routes setup</a></li>
                    <li><a href="#route-guard" id="markdown-toc-route-guard">Route Guard</a></li>
                    <li><a href="#actions" id="markdown-toc-actions">Actions</a></li>
                    <li><a href="#effects" id="markdown-toc-effects">Effects</a></li>
                </ul>
            </div>
            <h3 id="routes-setup">
                <a href="#routes-setup" class="linkjuice">
                    <span class="linkjuice-icon">
                        <i class="linkjuice__icon"></i>
                    </span>
                    Routes setup
                </a>
            </h3>
            <p>Let's take a snippet from the code I'm currently working on, where I have a higher level <code class="highlighter-rouge">CourseComponent</code> which embeds a <code class="highlighter-rouge">&lt;router-outlet&gt;</code> for child routes.</p>
            <p>On the route, I've got a <code class="highlighter-rouge">canActivate</code> property which passes in my <code class="highlighter-rouge">CoursesGuard</code>. The role of this guard is to actually check our Store for data, and dispatch an action to make an API request if there's no data.</p>

        </div>
        <h3 id="route-guard">
            <a href="#route-guard" class="linkjuice">
                <span class="linkjuice-icon">
                    <i class="linkjuice__icon"></i>
                </span>
                Route Guard
            </a>
        </h3>
        <p>First, let's assume the basics of a typical Route Guard:</p>

        <p>Now let's add some further code and explain:</p>
        <p>This technique is quite nice, simple and readible. Here's the full non-annotated source code:</p>
        <div class="language-js highlighter-rouge">
        </div>
        <h3 id="actions">
            <a href="#actions" class="linkjuice">
                <span class="linkjuice-icon">
                    <i class="linkjuice__icon"></i>
                </span>
                Actions
            </a>
        </h3>
        <p>I'm using a few actions to manage the <code class="highlighter-rouge">GET</code> request to the courses API, here's a glimpse of the actions which you can see <code class="highlighter-rouge">CoursesGet()</code> being used in the above guard:</p>
        <div class="language-js highlighter-rouge">
        </div>
        <p>In typical redux, you'd do something like:</p>
        <div class="language-js highlighter-rouge">

        </div>
        <p>This class based approach allows us for better type checking and <code class="highlighter-rouge">payload</code> configuration - as well as the logic being contained in a single place which is simply imported and a new instance of an action is created.</p>
        <p>Let's finish this off by taking a look at the <code class="highlighter-rouge">ngrx/effects</code> side of this logic.</p>
        <h3 id="effects">
            <a href="#effects" class="linkjuice">
                <span class="linkjuice-icon">
                    <i class="linkjuice__icon"></i>
                </span>
                Effects
            </a>
        </h3>
        <p>The effect for this simply listens for the <code class="highlighter-rouge">COURSES_GET</code> action, and once invoked will hit the <code class="highlighter-rouge">.getCourses()</code> method on my <code class="highlighter-rouge">CoursesService</code></p>
        <div class="language-js highlighter-rouge">
        </div>
        <p>Once that's been 200 ok'd from the backend, the <code class="highlighter-rouge">.map()</code> then invokes a new action, passing in the payload - which then merges the new state in my reducer.</p>
    </section>
</article>